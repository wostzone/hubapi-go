// Package testenv for creating mosquitto testing environment
package testenv

import (
	"bytes"
	"fmt"
	"html/template"
	"io/ioutil"
	"os"
	"os/exec"
	"path"
	"time"

	"github.com/sirupsen/logrus"
	"github.com/wostzone/hubapi-go/pkg/certsetup"
)

const mosquittoConfigFile = "wost-mosquitto-test.conf"
const mqConfigTemplate = `
# Generated by SetupTestEnv. Do not edit.

log_type error
log_type warning
log_type information
log_dest stdout
persistence false
#acl_file {{.homeFolder}}/config/mosquitto.acl


#--- Consumers authenticate using a password
# MQTT over TLS/SSL
listener {{.clientPortMqtt}}
require_certificate false
tls_version tlsv1.2
cafile {{.homeFolder}}/certs/ca.crt
keyfile {{.homeFolder}}/certs/hub.key
certfile {{.homeFolder}}/certs/hub.crt
# Password Authentication for users
#password_file {{.homeFolder}}/config/mosquitto-passwd


# WebSockets over TLS/SSL
listener {{.clientPortWS}}
protocol websockets
require_certificate false
tls_version tlsv1.2
cafile {{.homeFolder}}/certs/ca.crt
keyfile {{.homeFolder}}/certs/hub.key
certfile {{.homeFolder}}/certs/hub.crt
# Password Authentication for users
#password_file {{.homeFolder}}/config/mosquitto-passwd


#--- Plugins authenticate using client certificate
# Plugin authentication MQTT over TLS/SSL with client certificate
listener {{.pluginPortMqtt}}
require_certificate true
tls_version tlsv1.2
cafile {{.homeFolder}}/certs/ca.crt
keyfile {{.homeFolder}}/certs/hub.key
certfile {{.homeFolder}}/certs/hub.crt

# Thing and Consumer authentication MQTT over TLS/SSL with login and password
listener {{.pluginPortWS}}
protocol websockets
require_certificate true
cafile {{.homeFolder}}/certs/ca.crt
keyfile {{.homeFolder}}/certs/hub.key
certfile {{.homeFolder}}/certs/hub.crt
# password_file ./config/mosquitto-passwd.txt
tls_version tlsv1.2
`

// Createa mosquitto.conf file for testing
func CreateMosquittoConf(port int, homeFolder string) string {
	// shoot a mosquitto with a bazooka
	var msg bytes.Buffer

	params := map[string]string{
		"homeFolder":     homeFolder,
		"clientPortMqtt": fmt.Sprint(port),
		"clientPortWS":   fmt.Sprint(port + 1), // FIXME, not like this :(
		"pluginPortMqtt": fmt.Sprint(port + 2),
		"pluginPortWS":   fmt.Sprint(port + 3),
	}
	tpl, err := template.New("").Parse(mqConfigTemplate)
	_ = err
	tpl.Execute(&msg, params)
	return msg.String()
	// return ""
}

// Setup a test environment with a mosquitto broker on localhost for the given home folder
// This:
//  1. Create CA, server and client certificates if they don't exist
//  2. Generates a mosquitto configuration in /tmp
//  3. Launches a mosquitto broker for testing.
//
// Run TeardownTestEnv() to end the mosquitto broker
//  homeFolder is the home directory to run from
//  mqttPort is the port to listen on, default (0) is 33100
// Returns the mosquitto process
func Setup(homeFolder string, mqttPort int) (mqCmd *exec.Cmd) {

	if mqttPort == 0 {
		mqttPort = 33100 // must match hub.yaml
	}
	certsFolder := path.Join(homeFolder, "certs")
	// configFolder := path.Join(homeFolder, "config")

	certsetup.CreateCertificateBundle("localhost", certsFolder)

	logrus.Infof("--- Starting mosquitto broker ---")
	// mqCmd = mosquitto.Launch(mosqConfigPath)

	// mosquitto must be in the path to execute
	mosqConf := CreateMosquittoConf(mqttPort, homeFolder)
	mosqConfigPath := path.Join("/tmp", mosquittoConfigFile)
	err := ioutil.WriteFile(mosqConfigPath, []byte(mosqConf), 0644)
	if err != nil {
		logrus.Fatalf("Setup: Unable to write mosquitto config file: %s", err)
	}
	mqCmd = exec.Command("mosquitto", "-c", mosqConfigPath)
	// Capture stderr in case of startup failure
	mqCmd.Stderr = os.Stderr
	mqCmd.Stdout = os.Stdout
	mqCmd.Start()
	go func() {
		mqCmd.Wait()
		logrus.Infof("--- Mosquitto has ended ---")
	}()
	// Give mosquitto some time to start
	time.Sleep(10 * time.Millisecond)

	return mqCmd
}

// Teardown the test environment and stop the mosquitto broker
func Teardown(cmd *exec.Cmd) {
	cmd.Process.Kill()
}
